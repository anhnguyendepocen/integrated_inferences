# Integrated inferences {#mixing}



```{r packagesused08, include = FALSE}
source("_packages_used.R")
```

<!-- Lots of this likely to change with integration with DAGs. -->



:::: {.headerbox data-latex=""}
::: {.center data-latex=""}
:::
We extend the analysis of Chapter \@ref(pt) to cases with population data. In these cases we get to learn   about the distribution of causal effects and are able to update the models we use for case level inference.
::::

<br>

The main goal of this chapter is to  generalize the model developed in Chapter \@ref(pt) to research situations in which we have data on multiple cases.  

We start however  with a conceptual point: the structure introduced in Chapter 6 for single case analysis can be used *as is* for multi-case analysis. Thus the  conceptual work for mixed methods inference from models has been done already. Our goal here is more technical---how to exploit assumptions regarding independence across cases to generate simpler models causal processes that affect many units. As we do so we provide microfoundations for the models in Chapter 6 (as with those in @humphreys2015mixing)  with the probative value of clues deriverable from a causal structure and data.


## There's only ever one case

Conceptualized correctly, there is no deep difference between the logic of  inference used in single case and many case studies. The reason is not, as @king1994designing suggest, that all causal inference is fundamentally correlational, even in seemingly single case studies. Nor is the point that single "case studies" can be disaggregated into many cases. The intuition, we think, really runs in the opposite direction: fundamentally, model-based inference always involves comparing *a* pattern of data with the logic of the model. Studies with multiple cases can be conceptualized  as single-case studies: the drawing of inferences from a single *collection* of clues.

In practice, when we move from a causal model with one observation to a causal model with multiple observations, we can use the  structure we introduced in Chapter 6 but simply replace nodes that have a single value (i.e., scalars) with nodes containing multiple values (i.e., vectors). We then make inferences about the relations between vectors from seeing the values of those vectors, or other vectors that serve as clues.

To illustrate, consider the following situation. There are two units studied, drawn from some population, a binary treatment $X$ is assigned independently with probability .5 to each case; an outcome $Y$ along with clue variable $K$ is observable.  We suppose  $X$ can affect $Y$ and in addition there is a background, unobserved, variable $\theta$ (causal type) that takes on values in $\{a,b,c,d\}$, that affects both $K$ and $Y$ (we interpret $\{a,b,c,d\}$ as introduced in section \@ref(counterfactualmodel)). In particular we suppose that in any given case $K=1$ whenever $X$ causes $Y$, and $K=1$ with a 50% probability otherwise. Thus, $K$ is informative about a unit's causal type. 

Note that we have described the problem at the unit level. However we can redescribe it at the population level thus:

* a treatment vector $X$ can take on one of four values, $(0,0), (0,1), (1,0), (1,1)$ with equal probability (or more strictly: as determined by $\theta$). 
* $\theta$ is also a vector with two elements that can take on one of 16 values $(a,a), (a,b),\dots (d,d)$ as determined by $\lambda_\theta$
* $K$ has the same domain as $X$ and $Y$, and element $K[j]=1$ if $\theta[j]=b$.
* $Y$ is a vector that reflects the elements of $\theta$ and $X$ in the obvious way (e.g $X=(0,0), \theta=(a,b)$ generates outcomes $Y=(1,0)$.

Say we are interested in the Sample Average Treatment Effect. We will  consider three operations, one in which both units have $X$ forced to 0 and two in which one unit has $X$ set to 0 and the other has $X$ set to 1. Thus we are interested in the average effect of changing one unit to treatment while the other is held in control. Note also that before our estimands were binary---of the form: is it a $b$ type?--and our answer was a probability; now our estimand is categorical and our answer is a distribution (what is the probability the SATE is 0, what is the probability the SATE is .5, etc...)


We now have a representation that maps directly onto the case level structures used in Chapters 6 and 7 and can use the tools introduced there to analyze this seemingly multi-case study. 

Inference...

Independence... 
You can see that that representing node values in vector forms like this allows for more general vector-level mappings that could involve SUTVA violations: for instance perhaps $Y_i=1$ if *either* $X_1$ or $X_2 = 1$. 
<!-- In the below we examine a situation in which we consider the value of observing $K$ on one case --- in this set up this is equivalent to observing part of the vector $K$ and making inferences on the full vector $\theta$. -->

```{r models, eval = FALSE, include = FALSE}
library(gbiqq)

model <- make_model("X->Y")

fit <- fitted_model()

updated_1 <- gbiqq(model, data = data.frame(X=1, Y=1), 
									 chains = 10, iter = 12000, fit = fit)

updated_2 <- gbiqq(model, data = data.frame(X=c(1,1,1,1), Y=c(1,1,1,1)), 
									 chains = 10, iter = 12000, fit = fit)

updated_3 <- gbiqq(model, data = data.frame(X=1, Y=NA), 
									 chains = 10, iter = 12000, fit = fit)

# query_model(query = "Y[X=1] - Y[X=0]", )

query_model(updated_1, 
						query = te("X","Y"), 
						given = c(TRUE, "X==1 & Y==1"), 
						using = c("parameters", "posteriors"), 
						expand_grid = TRUE )

query_model(updated_2, 
						query = te("X","Y"), 
						given = c(TRUE, "X==1 & Y==1"), 
						using = c("parameters", "posteriors"), 
						expand_grid = TRUE )

query_model(updated_3, 
						query = te("X","Y"), 
						given = c(TRUE, "X==1 & Y==1"), 
						using = c("parameters", "posteriors"), 
						expand_grid = TRUE )


# IMPORTANT TO DISTINGUISH BETWEEN:

# what is the chance that X caused Y given X=1, Y=1 and
# what is the chance that X causes Y given you have seen a case in which X=1, Y=1 and
# Only data that your query has not conditioned on is informative (is dta conditionnally independent of teh query)
```

## General procedure 

In practice however thinking of nodes as capturing the outcomes on all units leads to enormous complexity. For example an exogeneous variable $X$ which takes on values of 0 or 1 at random for 10 units has $2^{10}$ types in this conceptualization, rather than just two when thought of at the case level. 

We reduce complexity however by thinking of models as operating on units and learning about models by observing *multiple* realizations of processes covered by the model, rather than just one. Thinking about it this way is not free however as it requires invoking  independence assumptions --- that outcomes in two units do not depend on each other. If we cannot stand by that assumption, then we have to build independence failures into our models.

Taking this step the procedure we now use in the mixed methods works as follows:

**INTROUDCE CONCEPTS AND THEN ILLUSTRATE**

**A DAG**. As for process tracing, we begin with a graphical causal model specifying possible causal linkages between nodes. Our "chain" model for instance has DAG: $X \rightarrow M \rightarrow Y$.

**Nodal types**. Just as in process tracing, the DAG and variable ranges define the set of possible nodal types in the model---the possible ways in which each variable is assigned (if exogenous) or determined by its parents (if endogenous).

**Causal types**. And, again, a full set of nodal types gives rise to a full set of causal types, encompassing all possible combinations of nodal types across all nodes in the model.

**Priors**. The first difference between single- and multiple-case inference lies in how we set priors on causal types. In process tracing, we set parameter values for each nodal type (or conditional nodal type, for unobserved confounding). Our parameters---e.g., $\lambda^X_0$, $\lambda^Y_{01}$---represent our beliefs about the proportions of these types in the population. When we only observe a single data type---data on a single case---we do not have sufficient information to learn about the distribution of types in the population. And so we treat these population-level beliefs as fixed parameters, rather than priors that we update on. (What we update on, in process tracing, is our priors on whether a *given case* is of a particular type or set of types.) Likewise, uncertainty about those population-level parameters has no effect on our inferences for a single case. When we get to observe data on multiple cases, however, we have the opportunity to learn *both* about the cases at hand *and* about the population. Moreover, our level of uncertainty about population-level parameters will shape our inferences. We thus want our parameters (the $\lambda$'s) to be drawn from a prior *distribution* --- a distribution that expresses our uncertainty and over which we can update once we see the data. 

While different distributions may be appropriate to the task in general, uncertainty over proportions (of cases, events, etc.) falling into a set of discrete categories is usefully described by a Dirichlet distribution, as discussed in Chapter \@ref(bayeschapter). The parameters of a Dirichlet distribution (the $\alpha$'s) can be thought of as conveying both the relative expected proportions in each category and our degree of uncertainty. 

**ADD MULTILEVEL GRAPH**


:::: {.headerbox data-latex=""}
::: {.center data-latex=""}
:::
**Box: Setting priors**

For a model with no unobserved confounding, setting priors requires  specifying a prior distribution for each set of nodal types. Parameters are provided as vectors of positive numbers with one number for each nodal type. These numbers correspond to the $\alpha$ parameters of a Dirichlet distribution. The relative size of each number governs the the relative probability of each nodal type. The absolute sizes govern the certainty over the types. 

To wit. For a simple $X \rightarrow Y$ model, we have two parameter sets: one for $X$'s types and one for $Y$'s types. 

For $X$'s types, we specify $\alpha^X_0$ and $\alpha^X_1$, corresponding to the nodal types $\theta^X_0$ and $\theta^X_1$, respectively. A distribution of the form ($\alpha^X_0=100, \alpha^X_1=100)$ implies a lot of confidence that a given unit has $X=1$ with probability .5. A distribution of the form ($\alpha^X_0=.1, \alpha^X_1=.1)$ implies that either $X=1$ with a high probability (for all units) or  $X=0$ with a low probability (for all units), but we are not sure which. 

For $Y$'s types, we specify $\alpha^Y_{00}$, $\alpha^Y_{10}$, $\alpha^Y_{01}$, and $\alpha^Y_{11}$, corresponding to the nodal types $\theta^Y_{00}$, etc. So, for instance:

* $\alpha^Y_{00}=1$, $\alpha^Y_{10}=1$, $\alpha^Y_{01}=1$, and $\alpha^Y_{11}=1$ yields a uniform distribution in which all share allocations of types in the population are equally likely. 
* $\alpha^Y_{00}=3$, $\alpha^Y_{10}=3$, $\alpha^Y_{01}=3$, and $\alpha^Y_{11}=3$ puts more weight on share allocations in which the shares are relatively equal. 
* $\alpha^Y_{00}=5$, $\alpha^Y_{10}=5$, $\alpha^Y_{01}=10$, and $\alpha^Y_{11}=5$ puts greater weight positive causal effects than the other three types.
::::



**Unobserved confounding.** When there is unobserved confounding, we need parameter sets that allow for a joint distribution over nodal types. Thus, if we believe the likelihood of $X=1$ is correlated with whether or not $X$ has a positive effect on $Y$, we will need two parameter sets (rather than one) for $X$: one for $X$'s value when $\theta^Y = \theta^Y_{01}$ and one for $X$'s value when $\theta^Y \neq \theta^Y_{01}$. For each of these parameter sets, we specify two $\alpha$ parameters representing our beliefs about $X$'s assignment. We can draw $\lambda$ values for these conditional nodal types from the resulting Dirichlet distributions, as above, and can then calculate causal type probabilities in the usual way.

**Distributions over causal types.** For a model with any number of nodes, we can then imagine a draw of one $\lambda^j$ from its prior distribution for each node, giving a full $\lambda$ vector.  Any particular $\lambda$ vector, in turn, implies a probability distribution over *causal* types ($\theta$). With the help of a parameter matrix (mapping from parameters to causal types), we can then, just as with process tracing, calculate the prior probability that a case is of any particular causal type, given the parameter ($\lambda$) values we have drawn. Implicitly, then, our prior distribution over $\lambda$ gives rise in turn to a prior distribution over the causal type shares in the population.

**Event probabilities**. We now need to build a likelihood function that can map from beliefs about the world to data: i.e., that can tell us how likely we are to see a given data pattern---across multiple cases---under a given distribution of causal types in the population. The first step in building the likelihood function is to calculate event probabilities: the probability of observing a case of a particular data type given a particular population-level distribution of causal type shares (that is, given a $\lambda$ draw). We assume, for now, that we deploy the same data strategy for each case, collecting data on all nodes.

We denote an event probability for a given data pattern for variables $X, Y, \dots$ as $w_{x, y, \dots}$. For instance, the probability of observing $X=0, Y=1$ in a case (given $\lambda$) is $w_{01}$. An ambiguity matrix, just as for process tracing, tells us which causal types are consistent with a particular data type, as observed for a single case. To calculate the probability of the data given a distribution of causal types, we simply add together the probabilities of all of the causal types with which it is consistent. 

See, for instance, the parameter matrix and the ambiguity matrix in Tables \@ref(tab:parammmatrixmix) and \@ref(tab:ambigmatrixmix). We have indicated a single draw of $\lambda$ values (population type shares) in the parameter matrix, and these have been used to calculate the priors on causal types provided in the ambiguity matrix. Let's now calculate the event probability for each data type. Starting with $X=0, Y=0$, we can read off the ambiguity matrix that the consistent causal types are ($\theta^X_0, \theta^Y_{00}$) and ($\theta^X_0, \theta^Y_{01}$). The event probability, $w_{00}$, is then given by adding together the probabilities of these two causal types, $0.1 + 0.2 = 0.3$. All four event probabilities, for the four data types, are then calculated in the same way:

* $w_{00} = 0.1 + 0.2 = 0.3$
* $w_{10} = 0.1 + 0.1 = 0.2$
* $w_{01} = 0.1 + 0.2 = 0.2$
* $w_{11} = 0.2 + 0.1 = 0.3$

As any case must be of one and only one data type, the full set of event probabilities for a single $\lambda$ draw must naturally sum to $1$.

```{r parammmatrixmix, echo = FALSE}
XY <- make_model("X -> Y") %>% set_parameters(c(.4, .6, .3, .2, .2, .3))
paramXY <- get_parameter_matrix(XY) 
paramXY_with_params <-cbind(paramXY, Shares = XY$parameters)
kable(paramXY_with_params, caption = "A parameter matrix for a simple $X \rightarrow Y$ model (with no unobserved confounding), indicating a single draw of $\\lambda$ values from the prior distribution.")
```


```{r ambigmatrixmix, echo = FALSE}
ambiguityXY  <- get_ambiguities_matrix(XY)
ambXY_with_priors <- data.frame(cbind(ambiguityXY, prior = get_type_prob(XY)))
kable(ambXY_with_priors, caption = "An ambiguity matrix for a simple $X \rightarrow Y$ model (with no unobserved confounding), showing the priors over causal types arising from a single draw of $\\lambda$ from its prior distribution.")
```

For a case in which only partial data are observed, we follow the same basic logic as with partial process-tracing data. We retain all columns (data types) in the ambiguity matrix that are consistent with the partial data. So, for instance, if we observe only $Y=1$, we would retain both the $X=0, Y=1$ column and the $X=1, Y=1$ column. We then calculate the event probability by summing causal-type probabilities for all causal types that could have produced these partial data --- i.e., all those with a $1$ in *either* column.


**Likelihood**. Now that we know the probability of observing each data pattern in a *single* case given $\lambda$, we can use these event probabilities to aggregate up to the likelihood of observing a data pattern across multiple cases (given $\lambda$). With discrete variables, we can think of a given multiple-case data pattern simply as a set of counts: for, say, $X, Y$ data, we will observe a certain number of $X=0, Y=0$ cases ($n_{00}$), a certain number of $X=1, Y=0$ cases ($n_{10}$), a certain number of $X=0, Y=1$ cases ($n_{01}$), and a certain number of $X=1, Y=1$ cases ($n_{11}$). A data pattern, given a particular set of variables observed (a search strategy), thus has a multinomial distribution. The likelihood of a data pattern under a given search strategy, in turn, takes the form of a multinomial distribution conditional on the number of cases observed and the event probabilities for each data type, given a $\lambda$ draw.

Let us assume now that we have a 3-node model, with $X, Y$, and $M$ all binary. Let $n_{XYK}$ denote an 8-element vector recording the number of cases in a sample displaying each possible combination of $X,Y,K$ data, thus: $n_{XYM}=(n_{000},n_{001},n_{100},\dots ,n_{111})$. The elements of $n_{XYK}$ sum to $n$, the total number of cases studied. Likewise, let the event probabilities for data types given $\lambda$ be registered in a vector, $w_{XYK}=(w_{000},w_{001},w_{100},\dots ,w_{111})$. The likelihood of a data pattern, $\mathcal D$ is then:

$$
\Pr(\mathcal{D}|\lambda) = 
  \text{Multinom}\left(n_{XYK}|n, w_{XYK}\right)  \\
$$
In other words, the likelihood of observing a particular data pattern given $\lambda$ is given by the corresponding value of the multinomial distribution given the event probabilities. 

What if we have a mixture of search strategies? Suppose, for instance, that we have collected $X,Y$ data on a set of cases, and that we have additionally collected data on $M$ for a random subset of these. We can think of this as conducting quantitative analysis on a large sample and conducting in-depth process tracing on a subsample. We then can summarize our data in two vectors, the 8-element $n_{XYM}$ vector for the cases with process tracing, and a 4-element vector $n_{XY*} = (n_{00*},n_{10*},n_{01*},n_{11*}$ for the partial data on those cases with no process tracing. Likewise, we now have two sets of event probabilities: one for the cases with complete data, $w_{XYM}$, and a 4-element vector for those with partial data, $w_{XY*}$. Let $n$ denote the total number of cases examined, and $k$ the number for which we have data on $K$.

Now, assuming that each observed case represents an independent, random draw from the population, we can form the likelihood function as a product of multinomial distributions: 


$$
\Pr(\mathcal{D}|\theta) = 
  \text{Multinom}\left(n_{XY*}|n-k, w_{XY*}\right) \times \text{Multinom}\left(n_{XYK}|k, w_{XYK}\right)  \\
$$







<!-- |     **Causal types** $\rightarrow$     | $\theta^X_0,\theta^Y_{00}$ | $\theta^X_1,\theta^Y_{00}$ | $\theta^X_0,\theta^Y_{10}$ | $\theta^X_1,\theta^Y_{10}$ | $\theta^X_0,\theta^Y_{01}$ | $\theta^X_1,\theta^Y_{01}$ | $\theta^X_0,\theta^Y_{11}$ | $\theta^X_1,\theta^Y_{11}$ | Parameter values (a draw from the prior) | -->
<!-- |:--------------------------------------:|:--------------------------:|:--------------------------:|:--------------------------:|:--------------------------:|:--------------------------:|:--------------------------:|:--------------------------:|:--------------------------:|:-----------------------------------------:| -->
<!-- | **Population parameters** $\downarrow$ |                            |                            |                            |                            |                            |                            |                            |                            |                                           | -->
<!-- |              $\lambda^X_0$             |              0             |              1             |              0             |              1             |              0             |              1             |              0             |              1             |                    0.4                    | -->
<!-- |              $\lambda^X_1$             |              1             |              0             |              1             |              0             |              1             |              0             |              1             |              0             |                    0.6                    | -->
<!-- |            $\lambda^Y_{00}$            |              1             |              1             |              0             |              0             |              0             |              0             |              0             |              0             |                    0.3                    | -->
<!-- |            $\lambda^Y_{10}$            |              0             |              0             |              1             |              1             |              0             |              0             |              0             |              0             |                    0.2                    | -->
<!-- |            $\lambda^Y_{01}$            |              0             |              0             |              0             |              0             |              1             |              1             |              0             |              0             |                    0.2                    | -->
<!-- |            $\lambda^Y_{11}$            |              0             |              0             |              0             |              0             |              0             |              0             |              1             |              1             |                    0.3                    | -->
<!-- Table: (\#tab:parammmatrixmix). A parameter matrix for a simple $X \rightarrow Y$ model (with no unobserved confounding), indicating a single draw of $\lambda$ values from the prior distribution. -->

BOX

#### Likelihood and sampling


Say a data strategy seeks data on $X$ and $Y$ in 2 cases and seeks data on $M$ if ever $X=Y=1$.

The probability of each data type is as given in table below:


|type:     |prob:                        |
|----------|-----------------------------|
|$X1M0Y1$  |$\lambda^X_1(\lambda^M_{00}+\lambda^M_{10})(\lambda^Y_{11}+\lambda^Y_{10})$|
|$X1M1Y1$  |$\lambda^X_1(\lambda^M_{11}+\lambda^M_{01})(\lambda^Y_{11}+\lambda^Y_{01})$|
|$X0Y0$    |$\lambda^X_0(\lambda^M_{00}+\lambda^M_{01})(\lambda^Y_{00}+\lambda^Y_{01}) + \lambda^X_0(\lambda^M_{10}+\lambda^M_{11})(\lambda^Y_{00}+\lambda^Y_{10})$|
|$X0Y1$    |$\lambda^X_0(\lambda^M_{00}+\lambda^M_{01})(\lambda^Y_{10}+\lambda^Y_{11}) + \lambda^X_0(\lambda^M_{10}+\lambda^M_{11})(\lambda^Y_{01}+\lambda^Y_{11})$|
|$X1Y0$    |$\lambda^X_1(\lambda^M_{00}+\lambda^M_{10})(\lambda^Y_{00}+\lambda^Y_{01}) + \lambda^X_1(\lambda^M_{01}+\lambda^M_{11})(\lambda^Y_{00}+\lambda^Y_{10})$|

The two observations can be thought of as a multinomial draw from these five event types.

Alternatively they can also be thought of as the product of a draw from a strategy in which a set of units is drawn with observations on $X,Y$ only and another set is drawn with observations on $X, M, Y$.

In the single multinomial view we have the probability of seeing data with $X=Y=0$ in one case and $X=1, M=0, Y=1$ in another is:

* $2P(X=0, Y=0)P(X=1, M=0, Y=1)$

In the conditional strategy view we have

* $2P(X=0, Y=0)P(X=1, Y=1)P(M=0 | X=1, Y=1)$

In the two strategy view we have

* $P(X=0, Y=0)P(X=1, M=0, Y=1)$

which is the same up to a constant.

Say rather than conditioning $X=Y=1$ to examine $M$ one of the two cases were chosen at random to observe $M$ and it just so happend to be be a case with $X=Y=1$:

| type:    | prob:                                                                         |
|----------|-------------------------------------------------------------------------------|
|$X0Y0$    |$0.5\lambda^X_0(\lambda^M_{00}+\lambda^M_{01})(\lambda^Y_{00}+\lambda^Y_{01}) + 0.5\lambda^X_0(\lambda^M_{10}+\lambda^M_{11})(\lambda^Y_{00}+\lambda^Y_{10})$|
|$X0Y1$    |$0.5\lambda^X_0(\lambda^M_{00}+\lambda^M_{01})(\lambda^Y_{10}+\lambda^Y_{11}) + 0.5\lambda^X_0(\lambda^M_{10}+\lambda^M_{11})(\lambda^Y_{01}+\lambda^Y_{11})$|
|$X1Y0$    |$0.5\lambda^X_1(\lambda^M_{00}+\lambda^M_{10})(\lambda^Y_{00}+\lambda^Y_{01}) + 0.5\lambda^X_1(\lambda^M_{01}+\lambda^M_{11})(\lambda^Y_{00}+\lambda^Y_{10})$|
|$X1Y1$    |$0.5\lambda^X_1(\lambda^M_{00}+\lambda^M_{10})(\lambda^Y_{10}+\lambda^Y_{11}) + 0.5\lambda^X_1(\lambda^M_{11}+\lambda^M_{01})(\lambda^Y_{11}+\lambda^Y_{01})$ + |
|$X0M0Y0$  |$0.5\lambda^X_0(\lambda^M_{00}+\lambda^M_{01}))(\lambda^Y_{00}+\lambda^Y_{01})$|
|$X0M1Y0$  |$0.5\lambda^X_0(\lambda^M_{11}+\lambda^M_{10}))(\lambda^Y_{00}+\lambda^Y_{10})$|
|...       |                                                                               |
|$X1M1Y1$  |$0.5\lambda^X_1(\lambda^M_{11}+\lambda^M_{01})(\lambda^Y_{11}+\lambda^Y_{01})$|


In the single multinomial view we have the probability of seeing data with $X=Y=0$ in one case and $X=1, M=0, Y=1$ in another is now:

* $2P(X=0, Y=0)P(X=1, M=0, Y=1)$

In the conditional strategy view we have

* $2P(X=0, Y=0)P(X=1, Y=1)P(M=0 | X=1, Y=1)$

In the two strategy view we have

* $P(X=0, Y=0)P(X=1, M=0, Y=1)$

which is the same up to a constant.


### Estimation

WRITE GENERAL APPROACH

WEITE BAYES RULE AND REFER BACK TO CHAPTER


### Query

Describe and illustrate


<!-- ## Illustration  -->

<!-- Consider a generalization of the models introduced in Chapter 6 in which a treatment $X$ is a cause of both $K$ and $Y$, and outcome $Y$ is a product of both $X$ and $K$. Though $K$ is both a mediator and a moderator for the effect of $X$. There are now 16 nodal types for $Y$, 4 for $K$ and 2 for $X$, yielding 32 causal types. -->

<!-- To allow for the possibility of non-random selection of $X$ we will assume that the assignment probability for $X$ depends on $U^Y$. This is a feature shared also in the baseline model when we specify $\pi$ as a function of types $a$,$b$,$c$,$d$. -->

<!-- Our piors requires specifying: -->

<!-- 1. A distribution over the 15-dimensional simplex representing possible values of $\lambda^Y$--which in turn determine types $u^Y$. -->
<!-- 2. A distribution over the 3-dimensional vector representing possible values of $\lambda^K$,  which in turn determine types $u^K$. -->


<!-- The model is restricted in various ways. We assume now confounding in the assignemnt of $X$. Less obviously we implicitly assume that $K$ is independent of $\theta^Y$ conditional on $X$. -->

<!-- With these elements in hand, however, all we need now is to provide a mapping from these fundamental parameters to the parameters used in the baseline model to form the likelihood.  -->


<!-- The key transformation is the identification of causal types resulting from the 64 combinations of $\lambda^Y$ and $\lambda^K$. These are shown below. -->

<!-- TABLE TO SHOW CAUSAL TYPES -->

<!-- Consider the following matrices of values for $u_Y$ and $u_K$, where $\lambda_{pq}^{rs}$ is the probability that $u^Y = t_{pq}^{rs}$, meaning that $Y$ would take the value $p$ when $X=0, K=0$,  $q$ when $X=0, K=1$,  $r$ when $X=1, K=0$,  and $s$ when $X=1, K=1$. Similarly $\lambda_{w}^{z}$ is the probability that $u^K$ takes value  $t_{w}^{z}$  meaning that $K$ takes the value $w$ when $X=0$ and $z$ when $X=1$. -->


<!-- TABLE TO SHOW CONDITIONAL PROBABILITIES OF K GIVEN X=1 AND TYPE -->

<!-- These types are the *transformed parameters*; the probability of a type is just the sum of the probabilities of the fundamental types that compose it, formed by taking the product of the $\lambda^Y$ and $\lambda^K$ values marked in the rows and columns of  table \ref{tab:types}.  -->

<!-- Similarly $\phi_{tx}$ can be constructed as the probability of observing $K$ conditional on this type (again, sums of products of probabilities associated with cells in table  \ref{tab:types}). For instance, using the row and column indices in exponents (GIVE FULL LABELS) from table \ref{tab:types}: -->

<!-- $$\phi_{b1}=\frac{\lambda_K^2(\lambda_Y^2+\lambda_Y^4+\lambda_Y^6+\lambda_Y^8)+\lambda_K^4(\lambda_Y^2+\lambda_Y^4+\lambda_Y^{10}+\lambda_Y^{12})}{ -->
<!-- \lambda_K^1(\lambda_Y^3+\lambda_Y^4+\lambda_Y^7+\lambda_Y^8)+\lambda_K^2(\lambda_Y^2+\lambda_Y^4+\lambda_Y^6+\lambda_Y^8)+\lambda_K^3(\lambda_Y^3+\lambda_Y^4+\lambda_Y^11+\lambda_Y^{12})+\lambda_K^4(\lambda_Y^2+\lambda_Y^4+\lambda_Y^{10}+\lambda_Y^{12})}$$ -->



<!-- With these transformed parameters in hand, the likelihood is exactly the same as that specified in the baseline model. -->

## Illustrated inferences


### Chain model

show table with columns:  
* 14 columns: 10 nodel types, high abcd 4 
* no data, 
* 1 data  point on X=1 Y=1 only
* 1 data  point on X=1 Y=1 M = 1 
* 10 data  point on X=1 Y=1 only
* 10 data  point on X=1 Y=1 M = 1 

## Considerations 

### The DAG can be enough when $N > 1$

In Chapter \@ref(pt), we discussed the fact that a DAG by itself is insufficient to generate learning about causal effects from data on a single case; we also need prior beliefs about population-level shares of nodal types. When working with multiple cases, however, we *can* learn about causal effects when starting with nothing more than the DAG. In particular, it is sometimes possible to draw causal information from correlations across cases, given only the DAG.

For instance, in an $X \rightarrow M \rightarrow Y$ model, even if we start with flat priors over $M$'s nodal types, observing a correlation (or no correlation) between $X$ and $M$ across multiple cases provides information about $X$'s effect on $M$. Simply, a stronger, positive (negative) $X, M$ correlation implies a stronger positive (negative) effect of $X$ on $M$. In turn, a stronger $X,M$ correlation implies a stronger effect of $X$ on $Y$ since, under this model, that effect has to run through an effect of $X$ on $M$. 

What's more, data from multiple cases can *provide* probative value for within-case inference. Suppose, for the $X \rightarrow M \rightarrow Y$ model, that we start with flat priors over all nodal types. As discussed in Chapter \@ref(pt), observing $M$ in a single case cannot be informative about $X$'s effect on $Y$ in that case. If we have no idea of the direction of the intermediate causal effects, then we have no idea which value of $M$ is more consistent with an $X \rightarrow M$ effect or which an $M \rightarrow Y$ effect. But suppose that we first observe data on $X$ and $M$ for a group of cases and find a strong positive correlation between the two variables. We now update to a belief that any effect of $X$ on $M$ is more likely to be positive than negative. Now, let's say we look at one of our cases, in which $X=1$ and $Y=1$ and want to know if $X$ caused $Y$. Knowing now that any such effect would most likely have operated via a positive $X \rightarrow M$ effect means that observing $M$ will be informative: $M=1$ will be more consistent with an $X \rightarrow Y$ effect than will $M=0$. The same logic, of course, also holds for observing cross-case correlations between $M$ and $Y$.

Drawing probative value from cross-case data is, of course, dependent on the causal model. For instance, if there is confounding between $M$ and $Y$, we would not derive probative value on $M$ from observing 

### Learning without identification

Some causal queries are "identified" while others are not. When a query is identified, each true value for the query is associated with a unique data distribution given infinite data. As we gather more and more data, our posterior on the query should converge on the true value. When a query is not identified, multiple true values of the query will be associated with the same data distribution given infinite data. With a non-identified query, our posterior will never converge on a unique value regardless of how much data we collect; multiple answers will be equally consistent with the data.

We can illustrate the difference by comparing an $ATE$ query to a probability of causation query for a simple $X \rightarrow Y$ model. When asking about the $ATE$, we are asking about the average effect of $X$ on $Y$, or the difference between $\lambda^Y_{01}$ (share of units with positive effects) and $\lambda^Y_{10}$ (share with negative effects). When asking about the probability of causation, we are asking, for a case with given values of $X$ and $Y$, about the probability that $X$ caused $Y$ in that case. This query is defined by a different set of parameters. For, say, an $X=1, Y=1$ case and our $X \rightarrow Y$ model, the probability of causation is given by just $\lambda^Y_{01}$. 

Let us assume a "true" set of parameters, unknown to the researcher, such that $\lambda^Y_{01} = 0.6$, $\lambda^Y_{10} = 0.1$ while we set $\lambda^Y_{00} = 0.2$ and $\lambda^Y_{11} = 0.1$. Thus, the true average causal effect is $0.5$. We now use the parameters and the model to simulate a large amount of data ($N=10,000$). We then return to the model, set flat priors over nodal types, and update the model using the simulated data. We graph the posterior on our two queries, the $ATE$ and the probability of positive causation in an $X=1, Y=1$ case, in Figure \@ref(PChist).


```{r, echo = FALSE} 
if(do_diagnosis){
ATE_dist <- query_distribution(
                   model = updated, 
                   using = "posteriors",
                   query = "Y[X=1] - Y[X=0]"
                   )
PC_dist <- query_distribution(
                   model = updated, 
                   using = "posteriors",
                   query = "Y[X=1] > Y[X=0]",
                   given = "X==1 & Y==1"
                   )
write_rds(ATE_dist, "saved/appendix_ATE_dist.rds")
write_rds(PC_dist, "saved/appendix_PC_dist.rds")
}
ATE_dist <- read_rds("saved/appendix_ATE_dist.rds")
PC_dist  <- read_rds("saved/appendix_PC_dist.rds")
```

```{r PChist, echo = FALSE, fig.cap = "ATE is identified, PC is not identified but has informative bounds"}
par(mfrow = c(1,2))
hist(ATE_dist, xlim = c(-1,1), main = "Posterior on ATE", xlab = "ATE")  
hist(PC_dist, xlim = c(0,1), main = "Posterior on PC", xlab = "Probability X=1 caused Y=1")  
```

The figure illustrates nicely the difference between an identified and non-identified query. While the $ATE$ converges on the right answer, the probability of causation fails to converge even with a massive amount of data. We see instead a range of values for this query on which our updated model places roughly equal posterior probability.

Importantly, however, we see that we *do* learn about the probability of causation. Despite the lack of convergence, our posterior rules out a wide range of values. While our prior on the query was 0.5, we have correctly updated toward a range of values that includes (and happens to be fairly well centered over) the true value ($\approx 0.86$). 

A distinctive feature of updating a causal model is that it allows us to learn about non-identified quantitites in this manner. We will end up with "ridges" in our posterior distributions: ranges or combinations of parameter values that are equally likely given the data. But our posterior weight can nonetheless shift toward the right answer.

At the same time, for non-identified queries, we have to be cautious about the impact of our priors. As $N$ becomes large, the remaining curvature we see in our posteriors may simply be function of those priors. One way to inspect for this is to simulate a very large dataset and see whether the curvature remainsXXXXXXXXXX A second approach would be to do sensitivity analyses by updating the model on the same data with different sets of priors to see how this affects the shape of the posterior.

<!-- Identified quantity is that each true theta, with infinite data, has a unique data distribution associated with it. If not identified, multiple different thetas will have different infinite-data distributions associated with them. E.g., COE. If it's the same, you won't know which it is. This is why we'll get ridges in the posteriors. So as you scale up data, you might rule out other things, but those theta's will always scale up together. So you'll never discriminate between those, but you'll learn about those things relative other things. -->

<!-- Use Fig. 6.1 from Causal Models guide. -->

<!-- So that's still learning. We can learn about unidentified quantities.   -->

<!-- But the bad news is that, for a not-identified quantity, your priors will matter: the curvature that gives us a maximum in our posterior will be driven by the posteriors. To distinguish between what part of the posterior is from the data and what's from the data would be to simulate infinite data and see what happens to the  -->

<!-- Can also do sensitivity analyses by changing priors. -->



```{r modelm1m2}
model <- make_model("X1 -> M1 -> Y <- M2 <- X2")

# restrict such that *only* M1 OR M2 could cause Y -- can we create a DD test? / achieve identification

```


### Beyond binary data

While the setup used in this book involves only binary nodes, the approach described here readily generalizes to other levels of measurement. A shift to other levels of measurement can be straightforwardly accommodated through an expansion of the nodal-type space.

Suppose that we want to operate with variables with 3 ordinal categories. In an $X \rightarrow Y$ model, $Y$'s nodal types have to accommodate 3 possible values that $X$ can take on, and 3 possible values that $Y$ can take on for any value of $X$. This yields 27  nodal types: 27 possible sets of $Y$ values corresponding to the 3 values that $X$ could take on. Notably, moving to 3-level ordinal variables already allows for considerably greater flexibility in response functions. For instance, relations could be non-linear, with $Y$ increasing as $X$ goes from 0 to 1, and then remaining flat as $X$ goes from 1 to 2. Relations could also be non-monotonic, with $Y$ increasing as $X$ goes from 0 to 1, and then *decreasing* as $X$ goes from 1 to 2. 

Of course, we extend this approach to make measurement arbitrarily fine-grained and allow for arbitrarily complex functional forms . More generally, allow $Y$ to take on $m$ possible values. With $k$ explanatory variables, each taking on $r$ possible values, we then have $m^{r^k}$ nodal types for $Y$. Thus, the cost of more granular measurement is complexity -- an explosion of the parameter space -- as the nodal type space expands rapidly with the granularity of measurement and the number of explanatory variables With 3 3-level ordinal variables pointing into the same outcome, we have $3^{27} = 7.6$ *trillion* nodal types!

We expect that, as measurement becomes more granular, researchers will want to manage the complexity by placing structure onto the possible patterns of causal effects. Structure, imposed through model restrictions, can quite rapidly tame the complexity. For some substantive problems, one form of structure we might be willing to impose is monotonicity. In our $X \rightarrow Y$ model with 3-level variables, excluding non-monotonic effects brings down the number of nodal types from 27 to 17.  Alternatively, we may have a strong reason to rule out effects in one direction: disallowing negative effects, for instance, brings us down to 10 nodal types. If we are willing to assume linearity the number of nodal types plummets to 5.

Of course, standard approaches to empirical modeling typically impose a great deal of structure -- consider, for instance, the ubiquity of the linearity assumption in regression modeling -- for precisely the same reason: to simplify the parameter space. As with other forms of empirical modeling, researchers working with causal models will need to decide how they want to trade off model fit and complexity of the parameter space in the choices they make about nodal measurement and model restrictions. 



<!-- We can still think in terms of types -->

<!-- With 3 levels of X and 3 levels of Y, you have 27 possible types. But if you impose linearity, only 5 types. If it's non-negative, there will be a few more. -->

<!-- Warning: gets very complicated -->

<!-- Possible strategy is to impose structure, which other approaches also do.  -->

<!-- Asymptotically approaches linearity -->




### Measurement error

One potential application of the approach we have described in this chapter to integrating differing forms of data is to addressing the problem of measurement error. The conceptual move to address measurement error in a causal model setup is quite simple: we incorporate the error-generating process into our model.

Consider, for instance, a model in which we build in a process generating measurement error on the dependent variable.

$$X \rightarrow Y  \rightarrow Y_\text{measured} \leftarrow \text{source of measurement error}$$ 

Here $X$ has an effect on the true value of our outcome of interest, $Y$. The true value of $Y$, in turn, has an effect on the value of $Y$ that we measure, but so too does a potential problem with our coding process. Thus, the measured value of $Y$ is a function of both the true value and error.

To motivate the setup, imagine that we are interested in the effect of a rule restricting long-term care staff to working at a single site ($X$) on novel coronavirus outbreaks in long-term care facilities ($Y$), defined as infections among two or more staff or residents. We do not directly observe infections, however; rather, we observe positive results of PCR tests. We also know that testing is neither comprehensive nor uniform. For some units, regular random testing is carried out on staff and residents while in others only symptomatic individuals are tested. It is the latter arrangement that potentially introduces measurement error.  

If we approach the problem naively, ignoring measurement error and treating $Y_\text{measured}$ as though it were identical to $Y$, we would face attenutation bias in our estimates of the effect of $X$ on $Y$ if some units are engaged in only symptomatic testing and this generates missed outbreaks. A slightly more sophisticated approach would be to acknowledge this attenuation bias, treating our estimate of the $ATE$ as a lower bound. 

Yet we can go further if we work with the above causal model. Without any additional data, we can update on both $\lambda_Y$ and $\lambda_{Y_\text{measured}}$. We could, for instance, impose restrictions that exclude negative effects of $Y$ on  $Y_\text{measured}$.^[We might also set a flat prior on the prevalence of measurement error and exclude positive effects of measurement error on $Y_\text{measured}$.] Then, if we observe (say) a negative correlation between $X$ and $Y_\text{measured}$, we can update on the substantive effect of interest -- $\lambda_Y$ -- in the direction of a larger share of negative effects: it is only *via* negative effects of $X$ on $Y$ that a negative correlation between $X$ and $Y_\text{measured}$ could emerge. At the same time, we learn about the measure as we update on $\lambda_{Y_\text{measured}}$: the negative observed correlation $X$ and $Y_\text{measured}$ is an indicator of the degree to which $Y_\text{measured}$ is picking up true $Y$.

We can do considerably better, however, if we can collect more detailed information on at least some units. One data strategy would be to invest in observing, $Y$, the true outbreak status of each unit for a subset of units on which we already have data on $X$ and $Y_\text{measured}$ --- say, by implementing our own random-testing protocol at a set of facilities. Observing both $X$ and the true $Y$ will allow us to update more directly on $\lambda_Y$, the true effect of $X$ on $Y$. Just as importantly, observing both $Y$ and $Y_\text{measured}$ will allow us to update more directly on measurement quality, $\lambda_{Y_\text{measured}}$. 

A second data strategy (which could be combined with the first) would be to collect data, for some subset of units, on the source of the measurement error. If we collected data on the use of random vs. symptomatic-only testing, we could then update on two further parameters: $\lambda_\text{source of measurement error}$ and on the part of $\lambda_{Y_\text{measured}}$ representing response of $Y_\text{measured}$. In other words, we would learn both about how prevalent the conditions generating measurement error are and about much they throw off our measure. 



<!-- * What if we are naive: attenuation bias with binary -->
<!-- * What if we are aware of risks but don't know how bad bad coding is -->
<!-- * What if we observed bad coding in a subsample -->

<!-- We have assumed no measurement error; in applications there could be considerable interest in measurement error. On one hand clue information may contain information about possible mismeasurement on $X$ and $Y$; on the other hand there might interest in whether measured clues adequately capture those features of a causal process that is thought to be measureable.   -->

<!-- The probability of different types of measurement error can be included among the set of parameters of interest, with likelihood functions adjusted accordingly. Suppose, for instance, that with probability $\epsilon$ a $Y=0$ case is recorded as a $Y=1$ case (and vice versa). Then the event probability of observing an $X=1$,$Y=1$ case, for example, is $\epsilon \lambda_a \pi_a + (1-\epsilon) \lambda_b \pi_b + \epsilon \lambda_c \pi_c + (1-\epsilon) \lambda_d \pi_d$. %If instead there were measurement error on $X$ but not on $Y$, then the event probability would be: $\epsilon \lambda_a (1-\pi_a) + (1-\epsilon) \lambda_b \pi_b + \epsilon \lambda_d (1-\pi_d) + (1-\epsilon) \lambda_d \pi_d$.  -->
<!-- Similar expressions can be derived for measurement error on $X$ or $K$. Specifying the problem in this way allows us both to take account of measurement error and learn about it. -->

### Spillovers

Spillovers may also be addressed through an appropriate definition of causal types. For example a unit $i$ that is affected either by receiving treatment or via the treatment of a neighbor, $j$, might have potential outcomes $Y_i(X_i,X_j)=\max(X_i,X_j)$ while another type that is not influenced by neighbor treatment status has  $Y_i(X_i,X_j)=\max(X_i)$. With such a set-up, relevant clue information might discriminate between units affected by spillovers and those unaffected.   

### Clustering and other violations of independence

### Parameteric models

### Prior data/beliefs "channel" the learning from new data 

When we learn from new data, we always update *conditional* on any prior information. Consider the following example. Suppose that we are working with our familiar $X \rightarrow M \rightarrow Y$ model. We first observe a large amount of $X,Y$ data in which the two variables are strongly and positively correlated, thus indicative of a positive $ATE$ of $X$ on $Y$. Next, we turn to process tracing a small number of cases: suppose we collect data on $M$ in one $X=1, Y=1$ case and one $X=0, Y=0$ case, and we observe $M=1$ in both cases. Well, $M$ is uncorrelated with $X$ across these two cases, constituting evidence against an effect of $X$ on $Y$. Since these are both cases in which a positive effect *could* have been operating, this finding will reduce our posterior on the share of positive effects in the population and, in turn, on the $ATE$. 

However, the strong prior information on the $ATE$ that we began with still anchors our updating. Our downward updating on the $ATE$ will be modest since our posterior is always a compromise between our (here, strong) priors and new information. More precisely, we will update less on the $ATE$, about which we had strong prior information, than we will update about the share of positive effects, about which our prior data provided weaker information. 

In addition, there is a knock-on effect for our beliefs about the share of negative effects in the population. If we have a strong prior about the value of the $ATE$, and our beliefs about the share of positive effects goes down substantially, then our beliefs about the share of negative effects must *also* fall. (Recall that the $ATE$ is simply the share of positive effects minus the share of negative effects.) Intuitively, we can think of our beliefs about negative effects as updating to "preserve" our beliefs about the $ATE$. And note that, if we had had *no* prior information about average effects, then learning about positive effects would have have had no implications for our beliefs about negative effects since there would be no overall constraint on the relationship between positive- and negative effect shares. 

A more general way to describe this dynamic is that learning about a kind of case that we directly observe can generate "second-hand" learning about a kind of case that we do not directly observe *through* the constraint on our beliefs imposed by the our priors. This is, really, just a special instance of our priors generating probative value: our prior on the $ATE$ can make evidence about positive effects informative about negative effects. If we had flat priors on the $ATE$, learning about positive effects would have no impact on our beliefs about negative effects.

A parallel example arises when we want to learn about a model with multiple causal pathways. Consider the model $X \rightarrow M \rightarrow Y \leftarrow N \leftarrow X$, where $X$ can have an effect on $Y$ through either $M$ or $N$. And let us set priors such that we believe the the two paths to be equally likely. Suppose that, as before, we have started with a substantial amount of $X,Y$ data indicative of a large positive $ATE$. Now, we look for data on $M$ in a handful of cases and find an $M$ pattern inconsistent with any kind of effect through $M$. What happens to our beliefs about the $ATE$? In general, finding evidence against one way an effect can happen should reduce our confidence in the effect happening at all. However, if we have started out with a strong prior on the $ATE$ but equal prior weight on the $M$ and $N$ pathways, then what we will see is countervailing updating across the two pathways: while our confidence in the operation of the $M$ pathway will fall substantially, our posterior on effects operating via the $N$ pathway will *rise* --- because of the constraint on the total effect imposed by our strong priors on the $ATE$. And our $ATE$ beliefs will fall only modestly. Evidence against the $M$-pathway effect will function as evidence for the $N$-pathway effects and, to a limited degree, as evidence against a total effect. 

A further implication for process tracing is that there will generally be sharp limits to what we can learn about total effects if we study mediators along only *some* of the theorized pathways if we already have some prior information about total effects. The difficulty is that whatever we learn from the mediators we *do* observe will be offset by countervailing shifts in our beliefs about other pathways, generated by the constraint in our prior knowledge about the total effect. Suppose, for instance, that we start with some belief that economic development makes democracy more likely, and we believe that there may be two mechanisms: one operating through a rising middle class and one operating through a more robust and organized working class. Suppose then that we examine data on the organization of the working class and find that it does not vary with per capita GDP. We will then, of course, reduce our confidence in the working-class pathway. However, we must also *increase* our confidence in the operation of the middle-class pathway --- because (a) we have prior reason to believe that the overall development $\rightarrow$ democracy effect exists and (b) we have not observed a mediator along the middle-class pathway. On balance, then, learning about just the one pathway will not have a large impact on beliefs about the overall effect of GDP on democratization. The larger lesson here is that, if our process tracing strategy involves the examination of mediators to learn about total $X \rightarrow Y$ effects, then how much we stand to learn depends on how comprehensively our examination of mediators covers thes plausible pathways connecting $X$ to $Y$.

To be clear, we do not need to collect mediator clues on all *possible* pathways. If we have strong priors that one or more possible pathways are very unlikley, then we might safely be able to avoid collecting observations along those pathways without substantially reducing the prospects for learning. 

Also, the specific point that we are making here applies to using mediator data to answer queries about the effect of $X$ on $Y$. If instead we want to know which *particular pathway* is operating, then the lesson here is quite different, and more encouraging. For one thing, collecting evidence on just one pathway can be highly informative about the operation of that pathway. For another, if we do have strong priors on the $ATE$, then learning about one pathway can *also* be informative about other pathways, just as we saw in our $M$- and $N$-pathway example.


## Principles of reasoning about learning

As we did in Chapter \@ref(pt), we provide here some guidance in how to reason about the learning that arises from mixed data. We focus especially on ways in which learning from multiple cases differs from learning from a single case.

<!-- AJ: We'd discussed this going here, but I think it would be better placed in a substantive chapter. This is where people will be more likely to look for it.  -->

<!-- 1. Learning requires uncertainty. And expected learning goes up as you become more uncertain about what youll find.  If your causal model puts a very high probability on X having a positive effect on M, and you already know Xs value, you should expect to learn very little from observing M since youre very likely to see exactly the M value you expect given X. (Currently in Chap. 12)((And we want to make research design choices based on expected learning, not based on the mere possibility of learning: yes, our beliefs will shift if we look for M and find the unexpected value. But because that data-realization is highly unlikely, we expect the learning from observing M to be minimal.  -->

<!-- 2. Pure within-case (or n=1) learning requires informative priors about the nodes to be observed. For instance, in a chain model, where we want to go and observe M, its not enough to have an informative prior about the X->Y relationship. We need an informative prior about the X->M or M->Y link in order to learn from M. For instance, are positive X->M effects more common than negative ones? -->

 

<!-- 4. If there are different ways a query can be satisfied, evidence against one of those ways is evidence against the query as a whole. Say we have a two-path model  with one direct and one indirect path  and we want to know if X affects Y. We observe a mediator, M, along the indirect path in a set of cases. If the M data pattern is inconsistent with an indirect effect, then this is also evidence against an overall effect. In general, finding evidence against one way the effect can happen reduces our confidence in the effect happening at all.  -->



<!-- Moreover, the degree to which prior data constrains learning depends, of course, on how much prior data we have. In the $X \rightarrow M \rightarrow Y$ model, if we have observed only a small amount of prior $X,Y$ data, then observing $M$ in a handful of cases will lead us to update more strongly on the $ATE$ in the above examples, then observing the M data in the on-the-regression-line cases will have a weaker impact on our beliefs about negative effects, and a bigger impact on our beliefs about ATE. Ditto for the 2-path model example. However, where prior data/beliefs on the ATE are strong, well learn less about the ATE, and more about negative effects (or the direct path).  -->

<!-- 7. If there are different ways in which a query can be satisfied, evidence against the likelier way is stronger evidence against the query than is evidence against an unlikelier way. In the 2-path model, if we started out thinking that the indirect effect was more likely than the direct effect, then evidence against the direct effect will have a bigger impact on our beliefs about the overall model.  -->

<!-- 8. It is difficult to get empirical leverage on very unlikely queries. And queries may be unlikelier than they appear. Suppose we start with the 2-path model, and want to know if X has a positive effect on Y that rests on a chain of positive effects via M. And suppose, importantly, that we begin with flat priors over all nodal types. Our intuitions likely tell us that this is exactly the kind of question for which an observation of M is the perfect empirical strategy. And that intuition is, in a sense, correct: we can indeed learn about the query by observing M. Seeing M=1 in an X=Y=1 case, for instance. would be evidence consistent with the query while M=0 would be inconsistent. Fine. ((But we will only learn a little from this observation. The reason is that the query itself has a very low prior probability. It may actually not be obvious at first glance just how unlikely our query is to be true. (After all, the model has two causal paths, and were asking if positive effects run through one of them, right? Not quite.) Seeing this requires us to think about the joint probabilities implied by the query. First, the query requires X to have a positive effect on M, which we think theres only a 25% chance of. In addition, the query puts a very narrow constraint on Ys possible nodal types:  Y has to have a nodal type in which M has a positive effect on Y when X does not change, and in which X does not have a positive effect on Y unless M changes from 0 to 1. This pair of conditions is met by only 2 of Ys 16 nodal types, implying a 12.5% chance. The prior on the query is thus 0.25 x 0.125 = 0.03125. Thus, while observing M=0 takes the probability of the query down to 0%, we started out very close to 0%! And observing M=1 results in only a small uptick, to about 6% because there remain many type combinations consistent with M=1 but that do not fit through the needle-eye of this query. -->

## Conclusion

ADD REFERENCE TO TABLE 1 OF FOR MIXED DATA "Ability and Achievement" Otis Duncan

