# (PART) Appendices {-}

# Analysis of canonical models with `gbiqq`  {#examplesappendix}


```{r, include = FALSE}
source("_packages_used.R")
# do_diagnosis <- TRUE
if(do_diagnosis & !exists("fit")) fit <- gbiqq::fitted_model()
```

***

We walk through  a set of canonical models and show how to define and analyze them using `gbiqq`.

***

## $X$ causes $Y$, no confounding

In the simplest  $X$ causes $Y$ model the ATE is identified but the "probability of causation" (PC) is not: we can however generally place bounds on PC.

The model can be written:

```{r}
model <- make_model("X -> Y")
plot_dag(model)
```

This sparse definition assumes that there is no confounding and no constraints on the ways $X$ relates to $Y$.

You can see the parameter matrix, which confirms this, showing the mapping from parameters to causal types:


```{r, eval= FALSE, echo = FALSE}
get_parameter_matrix(model)
```

```{r, echo = FALSE}
kable(get_parameter_matrix(model), caption = "Parameter matrix for X causes Y model without confounding")
```

We can simulate  data using the bare bones model and assuming a "true model" in which there is a true positive effect of 0.5.

```{r}
data <- simulate_data(model, n = 1000, 
                      parameters = c(.5, .5, .2, .1, .6, .1))
```

The kinds of inferences on the probability that $X$ has a positive effect on  $Y$ given different data is calculated as follows:

```{r, message = FALSE, warning = FALSE, eval = FALSE}
updated <- gbiqq(model, data)
```


```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  write_rds(gbiqq(model, data, refresh = 0), "saved/appendix_XY_model_1.rds")
  }
updated <- read_rds("saved/appendix_XY_model_1.rds")
```


We can then ask questions about particular estimands like this:

```{r}
ATE <- "Y[X=1] - Y[X=0]"
PC  <- "Y[X=1] > Y[X=0]"

results <- gbiqq::query_model(
 updated,
 queries = list(ATE = ATE, ATE = ATE, PC = PC, PC = PC),
 using = list("priors", "posteriors"))
```

```{r, echo = FALSE}
kable(results, digits = 2)
```

We see from the posterior variance on PC that PC is not identified (or more precisely they key feature is that this distribution does not tighten even with very large N).  For more intuition we graph the posteriors:



```{r, echo = FALSE} 
if(do_diagnosis){
ATE_dist <- query_distribution(
                   model = updated, 
                   using = "posteriors",
                   query = "Y[X=1] - Y[X=0]"
                   )
PC_dist <- query_distribution(
                   model = updated, 
                   using = "posteriors",
                   query = "Y[X=1] > Y[X=0]",
                   subset = "X==1 & Y==1"
                   )
write_rds(ATE_dist, "saved/appendix_ATE_dist.rds")
write_rds(PC_dist, "saved/appendix_PC_dist.rds")
}
ATE_dist <- read_rds("saved/appendix_ATE_dist.rds")
PC_dist  <- read_rds("saved/appendix_PC_dist.rds")

par(mfrow = c(1,2))
hist(ATE_dist, xlim = c(-1,1), main = "Posterior on ATE")  
hist(PC_dist, xlim = c(0,1), main = "Posterior on PC")  
```


We find that they do not converge but they do place positive mass in the right range. Within this range, the shape of the posterior depends on the priors only. 


## $X$ causes $Y$, with unmodelled confounding

An $X$ causes $Y$ model with confounding can be written:

```{r}
model <- make_model("X -> Y") %>%
         set_confound(list(X = "(Y[X=1]>Y[X=0])", X = "(Y[X=1]<Y[X=0])", X = "(Y[X=1] ==1)"))
plot_dag(model)
```


The parameter matrix here has more parameters than nodal types, reflecting the conditional assignment probabilities of $X$ -- $X$ can have different assignment probabilities for different nodal types for $Y$.

```{r, eval= FALSE, echo = FALSE}
get_parameter_matrix(model)
```


```{r, echo = FALSE}
kable(get_parameter_matrix(model), caption = "Parameter matrix for X causes Y model with arbitrary confounding")
```

With the possibility of any type of confounding, the best we can do is place "Mansky bounds" on the average causal effect. 

To see this, let's plot a histogram of our posterior on average causal effects, given lots of data:

```{r}
data <- simulate_data(
    model, n = 1000, 
    parameters = c(.5, .5, .5, .5, .5, .5, .5, .5, .1, .1, .7, .1))
```


```{r, message = FALSE, warning = FALSE, eval = FALSE}
updated <- gbiqq(model, data, refresh = 0)
```


```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  write_rds(gbiqq(model, data, refresh = 0), "saved/appendix_XY_model_2.rds")
  }
updated <- read_rds("saved/appendix_XY_model_2.rds")
```

```{r, echo = FALSE}
prior_ate <- query_distribution(updated, "c(Y[X=1] - Y[X=0])", using = "priors")
post_ate <- query_distribution(updated, "c(Y[X=1] - Y[X=0])", using = "posteriors")
par(mfrow= c(2,1))
    hist(prior_ate, xlim = c(-1,1), main = "Prior")
    hist(post_ate, xlim = c(-1,1), main = "Posterior")
```

The key thing here is that the posterior on the ATE has shifted, as it should, but it is not tight, even with large data. In fact the distribution of the posterior covers one unit of the range between -1 and 1.

## $X$ causes $Y$, with confounding modelled

Say now we have a theory that the relationship between $X$ and $Y$ is confounded by unobserved variable $C$. Although $C$ is unobserved we can still include it in the model and observe the confounding it generates by estimating the model on data generated by the model but assuming that we cannot observe $C$.

```{r, message = FALSE}
model <- make_model("C -> X -> Y <- C") %>%
         set_restrictions(causal_type_restrict = "(Y[X=1, C=.] < Y[X=0, C=.]) | (Y[C=1, X=.] < Y[C=0, X=.]) | (X[C=1] < X[C=0])") %>%
         set_parameters(type = "prior_mean")  
```

The ATE estimand in this case is given by:

```{r, echo = FALSE}
result <- gbiqq::query_model(
    model, 
    queries = list(ATE = "c(Y[X=1] - Y[X=0])"), 
    using = "parameters")

kable(result)
```

In the first column below we run a  regression using data generated from this model but with $C$ unobserved. The second column shows what we would estimate if were able to observe $C$.

```{r, echo = FALSE, results='asis'}
data <- simulate_data(model, n = 10000)

stargazer::stargazer(lm(Y~X, data = data), lm(Y~X + C, data = data), header = FALSE, type = 'html')
```

Our posteriors over the effect of $X$ on $Y$ and the effect of the unobserved confounder ($C$) on $Y$ have a joint distributed with negative covariance. 

To illustrate we will use the same data but assume priors from  model where we do not restrict the relationship between $C$ and $Y$  and show the joint distribution of our posteriors.

```{r}
model <- make_model("C -> X -> Y <- C")  %>%
         set_restrictions(causal_type_restrict = "(X[C=1] < X[C=0])") 
```


```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  write_rds(gbiqq::gbiqq(model, data, stan_model = fit, refresh = 0), "saved/appendix_modelled_confound.rds")
  }
updated <- read_rds("saved/appendix_modelled_confound.rds")

ate <- query_distribution(updated, "c(Y[X=1] - Y[X=0])", using = "posteriors")
confound <- query_distribution(updated, "c(Y[C=1] - Y[C=0])", using = "posteriors")
```

```{r, echo = FALSE}
plot(ate, confound)
abline(lm(confound~ate), col = "red")
```


## Simple mediation model

We define a simple mediation model and illustrate learning about  whether $X=1$ caused $Y=1$ from observations of $M$.

```{r}
model <- make_model("X -> M -> Y") %>%
         set_confound(confound = list(X = "M[X=1]==1")) %>%
         set_parameters(c(.5, .5, .2, .8, 
                          .2, 0, .8, 0, 
                          .2, 0, .8, 0))
```


```{r}
plot_dag(model)
```

Data and estimation:

```{r}
data <- simulate_data(model, n = 1000, using = "parameters")
```

```{r, message = FALSE, eval = FALSE}
updated <- gbiqq(model, data)
```

```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  write_rds(gbiqq(model, data, refresh = 0), "saved/appendix_XMY_simple.rds")
  }
updated <- read_rds("saved/appendix_XMY_simple.rds")
```

```{r}
result <- gbiqq::query_model(
    updated, 
    queries = list(COE = "c(Y[X=1] > Y[X=0])"), 
    subsets = c("X==1 & Y==1", "X==1 & Y==1 & M==0", "X==1 & Y==1 & M==1"),
    using = "posteriors")

```

```{r, echo = FALSE}
kable(result)
```

Note that observation of $M=0$ results in a 0 probability for the posterior that $X$ caused $Y$, while observation of $M=1$ has only a modest positive effect. The mediator thus provides a hoop test for the proposition that $X$ caused $Y$.

## Simple moderator model

We define a simple  model with a moderator and illustrate how updating about COE is possible using the value of  a mediator as a clue.


```{r}
model <- make_model("X -> Y; Z -> Y") 
plot_dag(model)

```


```{r}
data <- simulate_data(
    model, n = 1000, 
    parameters = c(.5, .5, .5, .5, 
                   .02, .02, .02, .02, .02, .02, .02, .02,
                   .02, .70, .02, .02, .02, .02, .02, .02))
```

```{r, message = FALSE, eval  = FALSE}
posterior <- gbiqq(model, data)
```

```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  write_rds(gbiqq(model, data), "saved/appendix_mod_simple.rds")
  }
updated <- read_rds("saved/appendix_mod_simple.rds")
```


```{r}
result <- gbiqq::query_model(
    updated, 
    queries = list(COE = "Y[X=1] > Y[X=0]"), 
    subsets = list("X==1 & Y==1", "X==1 & Y==1 & Z==0", "X==1 & Y==1 & Z==1"),
    using = "posteriors")

```

```{r, echo = FALSE}
kable(result)
```

As an exercise, define a model where, learning about a model with moderators allows you to tighten bounds on COE even without observing the value of the mediator.

## An IV model

We define a simple mediation model and illustrate learning about whether $X=1$ caused $Y=1$ from observations of $M$.

```{r}
model <- make_model("X -> M -> Y")  %>%
         set_confound(confound = list(M = "Y[M=1]==1")) 

plot_dag(model)
```


```{r, echo = FALSE}
pars <- c( .1, .2, .6, .1,
           .5, .5,
           .1, .1, .7, .1, 
           .1, .1, .7, .1)

data <- simulate_data(model, n = 1000, parameters = pars)
```

```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  updated <- gbiqq(model, data)
  write_rds(updated, "saved/appendix_IV_simple.rds")
  }
updated <- read_rds("saved/appendix_IV_simple.rds")
```


```{r, echo = TRUE}
result <- gbiqq::query_model(
    updated, 
    queries = list(ATE = "c(Y[M=1] - Y[M=0])"), 
    subsets = list(TRUE, "M[X=1] > M[X=0]",  "M==0",  "M==1"),
    using = "posteriors")

```

```{r, echo = FALSE}
kable(result)
```

We calculate the average causal effect for all and for the compliers and conditional on values of $M$.

## A model that allows application of the frontdoor criterion

## A model with a violation of sequential ignorability

## Learning from a collider

Pearl describes a  model similar to the following as case for which controlling for covariate $W$ induces bias in the estimation of the effect of $X$ on $Y$, which could otherwise be esimated without bias.

```{r}
model <- make_model("X -> Y <- S; S -> W") %>%
         set_confound(list(X = "W[S=1]==1")) %>%
         set_parameters(c(.1, .9, 
                          .5, .5, 
                          .9, .1, 
                          .1,.1,.7,.1,
                          .2, 0,0,0, 0,0,0,0, .6,0,0,0, 0,0,0,.2)) 

plot_dag(model)

data <- simulate_data(model, n =  20000)

```

The true effect of $X$ on $Y$ is .3 but the PC is quite different for units with $W=0$ and W=1$/

```{r, echo = FALSE, message = FALSE}

kable(
  gbiqq::query_model(model, queries = list(ATE = "Y[X=1] - Y[X=0]"), 
              using = "parameters",
              subsets = list(
                TRUE, 
                "X==1 & Y==1",
                "X==1 & Y==1 & W==0",
                "X==1 & Y==1 & W==1")))
```

Priors are:

```{r, echo = FALSE, message= FALSE}
kable(
  gbiqq::query_model(model, queries = list(ATE = "Y[X=1] - Y[X=0]"), 
              using = "priors",
              subsets = list(
                TRUE, 
                "X==1 & Y==1",
                "X==1 & Y==1 & W==0",
                "X==1 & Y==1 & W==1")))
```

The ATE can be gotten fairly precisely in a simple regression. But controlling for $W$ introduces bias:

```{r}
summary(lm(Y~X, data = data))$coef
summary(lm(Y~X+W, data = data))$coef
```

How does the Bayesian model do, with and without data on $W$?

```{r, echo = FALSE}
data_no_W <- data
data_no_W$W <- NA
```

```{r, eval = FALSE, echo = FALSE}
updated1 <- gbiqq(model, data)
updated2 <- gbiqq(model, data_no_W)
```

Inferences that do not use $W$ get ATE  right on average, but PC is not identified and statements about PC conditional on $W$ are not possible:

```{r, echo = FALSE}
if(do_diagnosis){
  updated1 <- gbiqq(model, data)
  write_rds(updated1, "saved/appendix_collider1.rds")
    updated2 <- gbiqq(model, data_no_W)
  write_rds(updated2, "saved/appendix_collider2.rds")

  }
updated1 <- read_rds("saved/appendix_collider1.rds")
updated2 <- read_rds("saved/appendix_collider2.rds")

```


```{r, echo = FALSE}
kable(gbiqq::query_model(updated2, 
              queries = "Y[X=1] - Y[X=0]", 
              using = "posteriors",
              subsets = list(
                TRUE, 
                "X==1 & Y==1",
                "X==1 & Y==1 & W==0",
                "X==1 & Y==1 & W==1")))

```

We see  including the collider does not induce error in estimation of the ATE, even though it does in a regression framework. It provides an ability to make different PC case level claims given W, but these are nevertheless far off in this example because we still do not have identification. 


```{r, echo = FALSE}
kable(gbiqq::query_model(updated1, queries = "Y[X=1] - Y[X=0]", 
              using = "posteriors",
              subsets = list(
                TRUE, 
                "X==1 & Y==1",
                "X==1 & Y==1 & W==0",
                "X==1 & Y==1 & W==1")))
```





## A model mixing observational and experimental data


We imagine that node $R$ indicates whether a unit was assigned to be randomly assigned to treatment assignment ($X=Z$ if $R=1$) or took on its observational value ($X=O$ if $R=0$). We assume the exclusion restriction that entering the experimental sample is not related to $Y$ other than through assignment of $X$. 


```{r}
model <- make_model("R -> X; O ->X; Z -> X; X -> Y") %>%
         set_restrictions(causal_type_restrict = 
                            "X[Z=1, R=1, O=0]!=1 | X[Z=0, R=1, O=0]!=0 | X[Z=1, R=1, O=1]!=1 | X[Z=0, R=1, O=1]!=0 | 
                             X[Z=1, R=0, O=0]!=0 | X[Z=0, R=0, O=0]!=0 | X[Z=1, R=0, O=1]!=1 | X[Z=0, R=0, O=1]!=1") %>%
         set_confound(list(O = "(Y[X=1]>Y[X=0])", O = "(Y[X=1]<Y[X=0])", O = "(Y[X=1] ==1)"))

plot_dag(model)
```

```{r, echo = FALSE, include = FALSE}
P <- get_parameter_matrix(model)
kable(P[,1:4])
```


The parameter matrix has just one type for $X$ since $X$ really operates here as a kind of switch, inheriting the value of $Z$ or $O$ depending on $R$. Parameters allow for complete confounding between $O$ and $Y$ by $Z$ and $Y$ are unconfounded.


```{r}
model <- set_parameters(model, c(.2, .8, 
                                 .8, .2, 
                                 .2, .8, 
                                 .8, .2, 
                                 .5, .5, 
                                 .5, .5, 
                                 1,
                                 .2, .2, .4, .2))
```



The estimands:

```{r, echo = FALSE}
result <- gbiqq::query_model(
    model, 
    queries = list(ATE = "c(Y[X=1] - Y[X=0])"), 
    subsets = list(TRUE, "R==0", "R==1"),
    using = "parameters")
kable(result)
```


The priors:

```{r, echo = FALSE}
result <- gbiqq::query_model(
    model, 
    queries = list(ATE = "c(Y[X=1] - Y[X=0])"), 
    subsets = list(TRUE, "R==0", "R==1"),
    using = "priors")
kable(result)
```

Data:


```{r}
data <- simulate_data(model, n = 600)

# Uncomment if data on $O$ is not available for cases assigned to $R=1$.
# data$O[data$R == 1] <- NA   
```


The true effect is .2 but naive analysis on the observational data would yield a srtongly upwardly biased estimate.

The gbiqq estimates are:

```{r, eval = FALSE}
posterior <- gbiqq(model, data)
```


```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  write_rds(gbiqq(model, data), "saved/appendix_exp_obs.rds")
  }
updated <- read_rds("saved/appendix_exp_obs.rds")
```

```{r, echo = FALSE}
result <- gbiqq::query_model(
    updated, 
    queries = list(ATE = "c(Y[X=1] - Y[X=0])"), 
    subsets = list(TRUE, "R==0", "R==1"),
    using = "posteriors")
kable(result)
```


Did observational data improve the estimates from the experimental data?


```{r, eval = FALSE}
posterior <- gbiqq(model, data[data$R==1,])
```


```{r, message = FALSE, warning = FALSE, include = FALSE}
if(do_diagnosis){
  write_rds(gbiqq(model, data[data$R==1,]), "saved/appendix_exp_obs_2.rds")
  }
updated <- read_rds("saved/appendix_exp_obs_2.rds")
```

```{r, echo = FALSE}
result <- gbiqq::query_model(
    updated, 
    queries = list(ATE = "c(Y[X=1] - Y[X=0])"), 
    subsets = list(TRUE, "R==0", "R==1"),
    using = "posteriors")
kable(result)
```


A key quantity of interest from this model is the average effect of treatment conditional on being in treatment in the observational group. We have:

```{r, echo = FALSE}
result2 <- gbiqq::query_model(
    updated, 
    queries = list(ATE = "c(Y[X=1] - Y[X=0])"), 
    subsets = list("R==1 & X==0", "R==1 & X==1", "R==0 & X==0", "R==0 & X==1"),
    using = "posteriors")

kable(result2)
```

## Transportation of findings across contexts

We study the effect of $X$ on $Y$ in country 1 and want to make inferences to country 2, Our problem however is that countries differ in terms of some feature, $W$, that is distributed differently in the two countries and that affects $Y$ via some mechanism $K$. 

[[We assume that we have an experiment in country 1 but only observational variation in country 2.]]

For instance, $X$ is cash and $Y$ is welfare. $W$ is background levels of conflict which affects welfare via security $K$, possibly differently in both countries. 

Although they differ, we have the following encompassing theory for both countries.



```{r}
model <- make_model("W -> K -> Y <- X")
```

```{r, echo = FALSE}
hj_dag(x = c(1:3, 1),
       y = c(1,1,1,0),
       names = c("W", "K", "Y", "X"),
       arcs = cbind(c(1,2,4), c(2,3,3))  
       )

```


`r if (knitr:::is_html_output()) '# References {-}'`

